@model List<ChessBoardApp.Models.ChessPiece>
@{
    Layout = null;
    var moves = ViewBag.Moves as List<ChessBoardApp.Models.Move>;
}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Schackbräde</title>
    <style>
        body {
            background-color: #2c2f33;
            color: white;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            padding-top: 50px;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #eeeed2;
        }

        .dark {
            background-color: #769656;
        }

        .piece {
            user-select: none;
            cursor: grab;
            width: 70px;
            height: 70px;
        }

        .square.drag-over {
            outline: 3px solid yellow;
        }

        .dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.3);
            position: absolute;
            pointer-events: none;
        }

        .moves {
            width: 220px;
            background: #23272a;
            border-radius: 8px;
            padding: 15px;
            height: 640px;
            overflow-y: auto;
            color: #eee;
        }

            .moves h2 {
                margin-top: 0;
                text-align: center;
            }

        ol {
            padding-left: 18px;
        }

        .error {
            color: #ff8484;
            text-align: center;
            margin-bottom: 8px;
        }

        #promotionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }

        #promotionChoices {
            background: #444;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 20px;
        }

            #promotionChoices img {
                width: 70px;
                height: 70px;
                cursor: pointer;
                transition: transform 0.2s;
            }

                #promotionChoices img:hover {
                    transform: scale(1.2);
                }
    </style>
</head>
<body>
    <div class="chessboard" id="board">
        @for (int row = 0; row < 8; row++)
        {
            for (int col = 0; col < 8; col++)
            {
                bool isLight = (row + col) % 2 == 0;
                var piece = Model.FirstOrDefault(p => p.Row == row && p.Col == col);

                <div class="square @(isLight ? "light" : "dark")" data-row="@row" data-col="@col">
                    @if (piece != null)
                    {
                        string folder = piece.Color == "white" ? "White" : "Black";
                        string fileName = piece.Type switch
                        {
                            "pawn" => "Pawn" + (piece.Color == "white" ? "W" : "B") + ".png",
                            "rook" => "Rook" + (piece.Color == "white" ? "W" : "B") + ".png",
                            "knight" => "Knight" + (piece.Color == "white" ? "W" : "B") + ".png",
                            "bishop" => "Bishop" + (piece.Color == "white" ? "W" : "B") + ".png",
                            "queen" => "Queen" + (piece.Color == "white" ? "W" : "B") + ".png",
                            "king" => "King" + (piece.Color == "white" ? "W" : "B") + ".png",
                            _ => ""
                        };
                        <img src="~/Pieces/@folder/@fileName" class="piece" draggable="true" />
                    }
                </div>
            }
        }
    </div>

    <div class="moves">
        <h2>Drag</h2>
        <div id="error" class="error" style="display:none;"></div>
        <ol id="moves">
            @if (moves != null)
            {
                foreach (var m in moves)
                {
                    <li>@m.Notation</li>
                }
            }
        </ol>
    </div>

    <div id="promotionModal">
        <div id="promotionChoices"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script>
        const board = document.getElementById('board');
        const movesList = document.getElementById('moves');
        const errorBox = document.getElementById('error');
        const promotionModal = document.getElementById('promotionModal');
        const promotionChoices = document.getElementById('promotionChoices');

        let pendingPromotion = null;
        let selectedSquare = null;
        let validMoves = [];

        function positionToNotation(row, col) {
            return String.fromCharCode('a'.charCodeAt(0) + col) + (8 - row);
        }

        function wireEvents() {
            const pieces = document.querySelectorAll('.piece');
            const squares = document.querySelectorAll('.square');
            let draggedPiece = null;
            let fromSquare = null;

            pieces.forEach(piece => {
                piece.addEventListener('dragstart', e => {
                    draggedPiece = e.target;
                    fromSquare = e.target.parentElement;
                    setTimeout(() => piece.style.visibility = 'hidden', 0);
                });
                piece.addEventListener('dragend', e => {
                    piece.style.visibility = 'visible';
                    draggedPiece = null;
                    fromSquare = null;
                });

                // Klicka på pjäs för att visa giltiga drag
                piece.addEventListener('click', async e => {
                    const parent = e.target.parentElement;
                    const from = positionToNotation(parseInt(parent.dataset.row), parseInt(parent.dataset.col));
                    selectedSquare = from;
                    const res = await fetch(`/Chess/GetValidMoves?pos=${from}`);
                    validMoves = await res.json();
                    showDots(validMoves);
                });
            });

            squares.forEach(square => {
                square.addEventListener('dragover', e => e.preventDefault());
                square.addEventListener('drop', async e => {
                    e.preventDefault();
                    if (!draggedPiece || !fromSquare) return;

                    const fromRow = parseInt(fromSquare.dataset.row);
                    const fromCol = parseInt(fromSquare.dataset.col);
                    const toRow = parseInt(square.dataset.row);
                    const toCol = parseInt(square.dataset.col);
                    const from = positionToNotation(fromRow, fromCol);
                    const to = positionToNotation(toRow, toCol);

                    // Pawn promotion
                    const isPawn = draggedPiece.src.includes("Pawn");
                    const isPromotionRow = (draggedPiece.src.includes("White") && toRow === 0) ||
                                           (draggedPiece.src.includes("Black") && toRow === 7);
                    if (isPawn && isPromotionRow) {
                        pendingPromotion = { from, to };
                        showPromotionMenu(draggedPiece.src.includes("White") ? "white" : "black");
                        return;
                    }

                    await makeMove(from, to);
                });
            });
        }

        function showDots(moves) {
            document.querySelectorAll('.dot').forEach(d => d.remove());
            moves.forEach(pos => {
                const square = document.querySelector(`.square[data-row="${8 - parseInt(pos[1])}"][data-col="${pos.charCodeAt(0) - 97}"]`);
                if (square) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    square.appendChild(dot);
                }
            });
        }

        function showPromotionMenu(color) {
            const pieces = ["queen", "rook", "bishop", "knight"];
            promotionChoices.innerHTML = "";
            pieces.forEach(p => {
                const img = document.createElement("img");
                img.src = `/Pieces/${color.charAt(0).toUpperCase() + color.slice(1)}/${p.charAt(0).toUpperCase() + p.slice(1)}${color === "white" ? "W" : "B"}.png`;
                img.onclick = () => {
                    promotionModal.style.display = "none";
                    promotePawn(p);
                };
                promotionChoices.appendChild(img);
            });
            promotionModal.style.display = "flex";
        }

        function promotePawn(newPiece) {
            fetch('/Chess/Promote', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `from=${pendingPromotion.from}&to=${pendingPromotion.to}&newPiece=${newPiece}`
            }).then(r => r.json())
              .then(() => location.reload());
        }

        async function makeMove(from, to) {
            await fetch('/Chess/Move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `from=${from}&to=${to}`
            });
            location.reload();
        }

        wireEvents();
    </script>
</body>
</html>
